\section{io/serial.h File Reference}
\label{db/d11/serial_8h}\index{io/serial.h@{io/serial.h}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int {\bf serial\_\-init} (const void $\ast$config\_\-struct)
\item 
char {\bf serial\_\-readchar} ()
\item 
int {\bf serial\_\-readline} (char $\ast$buffer)
\item 
int {\bf serial\_\-write} (const char $\ast$buffer)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Interface to a serial interface (wow, an interface of an interface... :-\/)

The prototypes contained in this file can be implemented multiple times to be adapted to different communication interfaces which can simulate a serial port (e.g. a real serial port, a TCP socket, a Unix socket,...). 

Definition in file {\bf serial.h}.



\subsection{Function Documentation}
\index{serial.h@{serial.h}!serial\_\-init@{serial\_\-init}}
\index{serial\_\-init@{serial\_\-init}!serial.h@{serial.h}}
\subsubsection[{serial\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}int serial\_\-init (const void $\ast$ {\em config\_\-struct})}\label{db/d11/serial_8h_a780f33805db9929dfe0215720973c20b}
Initializes the serial port using the values contained in the given struct. The type of the struct is not defined to allow each implementation to use a struct containing the values needed to set up its own communication interface.

For example, an implementation which connects to a serial port uses a struct which contains values to define the speed, partity and stop bits of the interface, while a testing implementation which simulates a serial port using a TCP socket needs to know the values for the host and port to which establish the connection.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em config\_\-struct}]An implementation dependent struct to hold the needed configuration settings. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if the initialization process ended sucessfully, an error code otherwise. 
\end{DoxyReturn}
\index{serial.h@{serial.h}!serial\_\-readchar@{serial\_\-readchar}}
\index{serial\_\-readchar@{serial\_\-readchar}!serial.h@{serial.h}}
\subsubsection[{serial\_\-readchar}]{\setlength{\rightskip}{0pt plus 5cm}char serial\_\-readchar ()}\label{db/d11/serial_8h_a4650ddb52ffe6a8395efb315ee5fa286}
Reads a single char from a serial interface, blocking until some character data is received.

\begin{DoxyPrecond}{Precondition}
The {\ttfamily serial\_\-init} function was already called and returned sucessfully. 
\end{DoxyPrecond}
\begin{Desc}
\item[{\bf Todo}]How can we handle errors of this function? Setting a timeout limit and a special return code could do the trick.\end{Desc}
\begin{DoxyReturn}{Returns}
The char read from the communication device. 
\end{DoxyReturn}
\index{serial.h@{serial.h}!serial\_\-readline@{serial\_\-readline}}
\index{serial\_\-readline@{serial\_\-readline}!serial.h@{serial.h}}
\subsubsection[{serial\_\-readline}]{\setlength{\rightskip}{0pt plus 5cm}int serial\_\-readline (char $\ast$ {\em buffer})}\label{db/d11/serial_8h_abd6ad4a121321105cea5607b5009ff6e}
Reads data from the communication device until a newline character is encountered, then saves the data to the buffer and returns the number of bytes read.

\begin{DoxyPrecond}{Precondition}
The {\ttfamily serial\_\-init} function was already called and returned sucessfully. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The data saved to the buffer does not contain any newline characters and is $\backslash$0 terminated.
\end{DoxyPostcond}
\begin{Desc}
\item[{\bf Todo}]Should we set a timeout option? Should we allow to configure the char sequence to identify a line break ($\backslash$n, $\backslash$r$\backslash$n or $\backslash$r)? 

Define the possible error numbers and their respective meaning.\end{Desc}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\rightarrow$} {\em buffer}]The pointer to the string buffer to which the read line has to be written.\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of characters written to the buffer if the operation completed successfully, a negative error code otherwise. 
\end{DoxyReturn}
\index{serial.h@{serial.h}!serial\_\-write@{serial\_\-write}}
\index{serial\_\-write@{serial\_\-write}!serial.h@{serial.h}}
\subsubsection[{serial\_\-write}]{\setlength{\rightskip}{0pt plus 5cm}int serial\_\-write (const char $\ast$ {\em buffer})}\label{db/d11/serial_8h_a775882b47c1ac472577ef12d5c7d0775}
Writes the data contained in the given character buffer to the communication device until the end of the string ($\backslash$0).

\begin{DoxyPrecond}{Precondition}
The {\ttfamily serial\_\-init} function was already called and returned sucessfully. 

The {\itshape buffer\/} string is correctly $\backslash$0 terminated.
\end{DoxyPrecond}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em buffer}]The string to write to the serial interface.\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of characters written if the operation completed successfully, a negative error code otherwise. 
\end{DoxyReturn}
