.TH "io/serial.h" 3 "20 Apr 2010" "Version 0.2" "BNG Bootloader" \" -*- nroff -*-
.ad l
.nh
.SH NAME
io/serial.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBserial_init\fP (const void *config_struct)"
.br
.ti -1c
.RI "char \fBserial_readchar\fP ()"
.br
.ti -1c
.RI "int \fBserial_readline\fP (char *buffer)"
.br
.ti -1c
.RI "int \fBserial_write\fP (const char *buffer)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Interface to a serial interface (wow, an interface of an interface... :-)
.PP
The prototypes contained in this file can be implemented multiple times to be adapted to different communication interfaces which can simulate a serial port (e.g. a real serial port, a TCP socket, a Unix socket,...). 
.PP
Definition in file \fBserial.h\fP.
.SH "Function Documentation"
.PP 
.SS "int serial_init (const void * config_struct)"Initializes the serial port using the values contained in the given struct. The type of the struct is not defined to allow each implementation to use a struct containing the values needed to set up its own communication interface.
.PP
For example, an implementation which connects to a serial port uses a struct which contains values to define the speed, partity and stop bits of the interface, while a testing implementation which simulates a serial port using a TCP socket needs to know the values for the host and port to which establish the connection.
.PP
\fBParameters:\fP
.RS 4
\fIconfig_struct\fP An implementation dependent struct to hold the needed configuration settings. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if the initialization process ended sucessfully, an error code otherwise. 
.RE
.PP

.SS "char serial_readchar ()"Reads a single char from a serial interface, blocking until some character data is received.
.PP
\fBPrecondition:\fP
.RS 4
The \fCserial_init\fP function was already called and returned sucessfully. 
.RE
.PP
\fBTodo\fP
.RS 4
How can we handle errors of this function? Setting a timeout limit and a special return code could do the trick.
.RE
.PP
\fBReturns:\fP
.RS 4
The char read from the communication device. 
.RE
.PP

.SS "int serial_readline (char * buffer)"Reads data from the communication device until a newline character is encountered, then saves the data to the buffer and returns the number of bytes read.
.PP
\fBPrecondition:\fP
.RS 4
The \fCserial_init\fP function was already called and returned sucessfully. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The data saved to the buffer does not contain any newline characters and is \\0 terminated.
.RE
.PP
\fBTodo\fP
.RS 4
Should we set a timeout option? Should we allow to configure the char sequence to identify a line break (\\n, \\r\\n or \\r)? 
.PP
Define the possible error numbers and their respective meaning.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP The pointer to the string buffer to which the read line has to be written.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters written to the buffer if the operation completed successfully, a negative error code otherwise. 
.RE
.PP

.SS "int serial_write (const char * buffer)"Writes the data contained in the given character buffer to the communication device until the end of the string (\\0).
.PP
\fBPrecondition:\fP
.RS 4
The \fCserial_init\fP function was already called and returned sucessfully. 
.PP
The \fIbuffer\fP string is correctly \\0 terminated.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP The string to write to the serial interface.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters written if the operation completed successfully, a negative error code otherwise. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for BNG Bootloader from the source code.
