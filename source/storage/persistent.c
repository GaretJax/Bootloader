/** 
 * @mainpage API Specification
 *
 * @author Elias Medawar, Simon Honegger, Yves Peissard, Jonathan Stoppani
 *
 * This document contains the whole API specification for the BNG Bootloader
 * project, as generated by the Doxygen documentation generator tool.
 * 
 * The document is built from the C sources into different formats, it's made
 * available in HTML and PDF formats. Please refer to the project's
 * documentation for the exact location of these documents.
 * 
 * The complete project (prosa) documentation is built from ReST sources using
 * Sphinx and can be found in HTML format at the address:
 * http://garetjax.github.com/Bootloader/
 *
 * @section Overview
 *
 * @todo  Move this documentation to another file or to the Sphinx documentation.
 *
 * Before presenting the in-depth API documentation, the UML diagram in Fig. 1.1
 * was created to present an higher-level overview of the API.
 *
 * The \c Controller "class" representes our \c main function, and is
 * responsible for the initialization of the various parts of the system,
 * their respective interconnection (serial interface initialization, command
 * registration,...) and the routing of every received command to the command
 * dispatcher, which will in turn call the right command passing the parsed
 * tokens as arguments.
 *
 * Each command will then execute its task interacting with either the
 * application manager or the configuration registry. 
 * 
 * @note
 *   - Different realation graphs are automatically generated by Doxygen during the
 *     build phase, please refer to them for an in-dept view.
 *   - In the diagram below, each package representes a component, a class a C
 *     source file and the methods, the different functions contained in the
 *     file (the only exception is the \c Command interface, which representes
 *     the type of a command like function).
 *   - The details about the function prototypes where omitted for the
 *     sake of clarity.
 *
 * @image html APIOverview.png "Figure 1.1 â€“ API Overview"
 * @image latex APIOverview.eps "API Overview" width=\textwidth
 *
 */


#include <stdio.h>


#include "persistent.h"

//!!!!!!!! Jumper 7 = OFF

#define FLASH_BASE_ADR		0x0u	
#define BLOCK_SIZE			512u //bytes
#define FLASH_OFFSET		0x2800u //words

static short * const FLASH_CMD_ADR_1 = (short*)(FLASH_BASE_ADR + 0x5555ul*2);
static short * const FLASH_CMD_ADR_2 = (short*)(FLASH_BASE_ADR + 0x2AAAul*2);

int pstorage_read(char * buffer, int block, int length){
	int i;
	for(i=block*BLOCK_SIZE; i < length;i++){
		buffer[i] = ((char*)(FLASH_OFFSET*2))[i];
	}
}

int pstorage_write(const char * buffer, int block, int length){
	int i;
	unsigned int startAdress = BLOCK_SIZE*block;
	int ret;
	for(i = block; i <= block + length/BLOCK_SIZE; i ++){
		int offset = i*BLOCK_SIZE;
		int processedBytes = (i-block)*BLOCK_SIZE;
	    int writeLength = (length-processedBytes < BLOCK_SIZE ? length - processedBytes : BLOCK_SIZE);
		ret = writeBlock((short*)(buffer+offset), (short*)offset, writeLength);
	}
	return ret;
}

int writeBlock(short * from, short * to, int offset){

	unsigned int i;
	unsigned int j;
	short lastShort;
	
	char* lastShortPtr = (char*)&lastShort;
	char* fromPtr = (char*)from;
	char* toPtr = (char*)to;

	*FLASH_CMD_ADR_1 = 0xAAAAu;
	*FLASH_CMD_ADR_2 = 0x5555u;
	*FLASH_CMD_ADR_1 = 0xA0A0u;
	
	for(i = 0; i < offset/2; i++){
		to[FLASH_OFFSET+i] = from[i];
	}

	
	if(offset % 2 > 0){
		lastShort = from[i];
		lastShortPtr[1]=0xFF;
		to[FLASH_OFFSET+i] = lastShort;
	}
	
	for(j = 0; j < offset/2; j++){
		while(to[FLASH_OFFSET+j] != from[j]){
			//wait till is written
		}
	}
	
	if(offset % 2 > 0){
		while(to[FLASH_OFFSET+j] != lastShort){
			//wait till is written
		}
	}
	
	return 0;
}

